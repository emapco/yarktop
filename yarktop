#!/usr/bin/env python3
#
# yarktop - Yet Another Rockchip `top`-like Tool
# Copyright (C) 2025  Emmanuel Cortes. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import contextlib
import math
import os
import queue
import re
import signal
import subprocess
import sys
import termios
import threading
import time
import tty
from typing import Any

import psutil
from rich import box
from rich.console import Group
from rich.layout import Layout
from rich.live import Live
from rich.panel import Panel
from rich.progress import BarColumn, Progress, TextColumn
from rich.table import Table

PREV_DISK = None
PREV_TIME = None
PREV_ADAPTERS = {}  # Per-adapter network stats: {adapter_name: (bytes_recv, bytes_sent)}
CACHE: dict[str, Any] = {
    "has_gpu": None,
    "has_npu": None,
    "has_rga": None,
    "sys_panel": None,
}
SORT_MODE = "cpu_desc"  # Default sorting mode
SHOULD_EXIT = False  # Flag for graceful shutdown


def signal_handler(signum, frame):
    """Handle SIGINT (CTRL+C) for graceful exit"""
    global SHOULD_EXIT
    SHOULD_EXIT = True


def get_key(q):
    old = termios.tcgetattr(sys.stdin)
    tty.setcbreak(sys.stdin.fileno())
    try:
        while True:
            b = os.read(sys.stdin.fileno(), 3).decode()
            k = ord(b[2]) if len(b) == 3 else ord(b)
            keymap = {
                127: "backspace",
                10: "return",
                32: "space",
                9: "tab",
                27: "esc",
                65: "up",
                66: "down",
                67: "right",
                68: "left",
            }
            q.put(keymap.get(k, chr(k)))
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old)


def human_bytes(val):
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if val < 1024:
            return f"{val:.1f} {unit}"
        val /= 1024
    return f"{val:.1f} PB"


def get_gpu_usage():
    """Read GPU utilization file and calculate usage percentage."""
    try:
        with open("/sys/kernel/debug/mali0/dvfs_utilization", "r") as f:
            line = f.readline()
            # Extract busy_time and idle_time values
            parts = line.strip().split()
            times = {
                parts[i].rstrip(":"): int(parts[i + 1]) for i in range(0, len(parts), 2)
            }
            busy_time = times.get("busy_time", 0.11)
            idle_time = times.get("idle_time", 0.11)
            total_time = busy_time + idle_time
            if total_time == 0:
                return 0.0
            gpu_usage = (busy_time / total_time) * 100
            return gpu_usage
    except Exception:
        return None  # Return None if GPU not available


def get_cpu_frequencies():
    """Read current frequency for each CPU core in MHz."""
    freqs = []
    cpu_id = 0
    while True:
        freq_path = f"/sys/devices/system/cpu/cpu{cpu_id}/cpufreq/scaling_cur_freq"
        try:
            with open(freq_path, "r") as f:
                freq_khz = int(f.read().strip())
                freqs.append(freq_khz // 1000)  # Convert to MHz
            cpu_id += 1
        except Exception:
            break
    return freqs


def get_gpu_frequency():
    """Read GPU frequency in MHz."""
    gpu_paths = [
        "/sys/devices/platform/fb000000.gpu-panthor/devfreq/fb000000.gpu-panthor/cur_freq",
        "/sys/class/devfreq/fb000000.gpu/cur_freq",
    ]
    for path in gpu_paths:
        try:
            with open(path, "r") as f:
                freq_hz = int(f.read().strip())
                return freq_hz // 1_000_000  # Convert to MHz
        except Exception:
            continue
    return None


def get_npu_frequency():
    """Read NPU frequency in MHz."""
    try:
        with open("/sys/class/devfreq/fdab0000.npu/cur_freq", "r") as f:
            freq_hz = int(f.read().strip())
            return freq_hz // 1_000_000  # Convert to MHz
    except Exception:
        return None


def get_npu_load():
    try:
        with open("/sys/kernel/debug/rknpu/load") as f:
            text = f.read()
        items = re.findall(r"Core(\d+):\s*(\d+)%", text)
        return [int(pct) for _, pct in items]
    except Exception:
        return []


def get_rga_load():
    """
    Read RGA (Rockchip Graphics Accelerator) load from debugfs.
    Returns tuple of (num_schedulers, dict of {scheduler_name: load_percentage})
    """
    rgaload = {}
    scheduler_id = 0
    with contextlib.suppress(Exception):
        with open("/sys/kernel/debug/rkrga/load", "r") as f:
            lines = f.readlines()
            csched = ""
            for line in lines:
                if "-" in line or "= load =" in line:
                    continue
                line = line.strip()
                if line.startswith("num of scheduler ="):
                    scheduler_id = int(line.split("=")[1])
                elif line.startswith("scheduler"):
                    csched = line.split(":")[1].strip()
                elif line.startswith("load ="):
                    load_percentage = line.split("=")[1].replace("%", "").strip()
                    rgaload[csched] = float(load_percentage)
    return scheduler_id, rgaload


def get_board_name():
    """
    Get the full board name from device tree.
    Returns the complete model string like "Radxa ROCK 5B" or similar.
    """
    paths = ["/proc/device-tree/model", "/sys/firmware/devicetree/base/model"]
    for p in paths:
        if os.path.exists(p):
            with contextlib.suppress(Exception):
                data = open(p, "rb").read().rstrip(b"\x00")
                model = data.decode("ascii", errors="ignore").strip()
                if model:
                    return model
    return "Unknown Board"


def get_rk_model():
    """
    Detect the Rockchip SoC model by reading the device tree.
    Returns something like "RK3588" or "RK3399" if available,
    or "Unknown RK" otherwise.
    """
    board_name = get_board_name()
    # Look for something like "RKxxxx"
    m = re.search(r"\b(RK\d+)\b", board_name, re.IGNORECASE)
    if m:
        return m.group(1).upper()
    return "Unknown RK"


def get_rga_version():
    """Read RGA driver version"""
    with contextlib.suppress(Exception):
        with open("/sys/kernel/debug/rkrga/driver_version", "r") as f:
            rgaver = f.read()
        return rgaver.split(":")[1].strip()
    return "Not Detected"


def get_npu_driver_version():
    """Read NPU kernel driver version"""
    with contextlib.suppress(Exception):
        with open("/sys/kernel/debug/rknpu/version", "r") as f:
            rkver = f.read()
        return rkver.split(":")[1].strip()
    return "Not Detected"


def get_librknnrt_version():
    """Read librknnrt library version"""
    with contextlib.suppress(Exception):
        output = subprocess.check_output(
            'strings /usr/lib/librknnrt.so | grep "librknnrt version:"', shell=True
        )
        ver = output.decode("utf-8").strip()
        ver = ver.replace("librknnrt version: ", "")
        return re.sub(r"\s*\(.*\)$", "", ver)
    return "Not Detected"


def get_librkllmrt_version():
    """Read librkllmrt library version"""
    with contextlib.suppress(Exception):
        output = subprocess.check_output(
            'strings /usr/lib/librkllmrt.so | grep "RKLLM SDK (version: "', shell=True
        )
        ver = output.decode("utf-8").strip()
        match = re.search(r"version:\s*([\d.]+)", ver)
        if match:
            return match.group(1)
    return "Not Detected"


def get_cpu_load():
    return psutil.cpu_percent(percpu=True, interval=0.1)


def get_mem_info():
    vm = psutil.virtual_memory()
    sm = psutil.swap_memory()
    return vm, sm


def get_thermal():
    temps = []
    with contextlib.suppress(Exception):
        for name, entries in psutil.sensors_temperatures().items():
            if not entries or entries[0].current is None:
                continue
            label = name.replace("_thermal", "")
            temps.append((label, math.floor(entries[0].current)))
    return temps


def get_top_processes(count=5, sort_mode="cpu_desc"):
    """Obtains the top processes sorted by the specified mode.

    Args:
        count (int, optional): number of processes to return. Defaults to 5.
        sort_mode (str, optional): Sorting mode - one of:
            'cpu_desc', 'cpu_asc', 'mem_desc', 'mem_asc',
            'pid_desc', 'pid_asc', 'name_desc', 'name_asc'
            Defaults to "cpu_desc".

    Returns:
        list: List of dictionaries with process information.
    """
    processes = []
    for proc in psutil.process_iter(
        attrs=["pid", "name", "username", "cpu_percent", "memory_percent"]
    ):
        try:
            info = proc.info
            if info.get("cpu_percent") is None:
                continue
            processes.append(
                {
                    "pid": info["pid"],
                    "name": info["name"] or "",
                    "user": info["username"] or "unknown",
                    "cpu": info["cpu_percent"] or 0.0,
                    "mem": info["memory_percent"] or 0.0,
                }
            )
        except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError):
            continue

    # Sort based on mode
    if sort_mode == "cpu_desc":
        processes.sort(key=lambda p: p["cpu"], reverse=True)
    elif sort_mode == "cpu_asc":
        processes.sort(key=lambda p: p["cpu"], reverse=False)
    elif sort_mode == "mem_desc":
        processes.sort(key=lambda p: p["mem"], reverse=True)
    elif sort_mode == "mem_asc":
        processes.sort(key=lambda p: p["mem"], reverse=False)
    elif sort_mode == "pid_desc":
        processes.sort(key=lambda p: p["pid"], reverse=True)
    elif sort_mode == "pid_asc":
        processes.sort(key=lambda p: p["pid"], reverse=False)
    elif sort_mode == "name_desc":
        processes.sort(key=lambda p: p["name"].lower(), reverse=True)
    elif sort_mode == "name_asc":
        processes.sort(key=lambda p: p["name"].lower(), reverse=False)

    return processes[:count]


def build_process_panel():
    """
    Build a panel showing processes with sorting controls.
    """
    global SORT_MODE

    top_processes = get_top_processes(count=24, sort_mode=SORT_MODE)

    # Determine current sort display
    sort_display = {
        "cpu_desc": "CPU↓",
        "cpu_asc": "CPU↑",
        "mem_desc": "Mem↓",
        "mem_asc": "Mem↑",
        "pid_desc": "PID↓",
        "pid_asc": "PID↑",
        "name_desc": "Name↓",
        "name_asc": "Name↑",
    }.get(SORT_MODE, "CPU↓")

    title = f"Sort: [C]PU [M]em [P]ID [N]ame | Current: {sort_display} | [Q]uit"
    table = Table(title=title, box=box.ROUNDED, expand=True, padding=(0, 1))
    table.add_column("PID", style="cyan", justify="right", width=4)
    table.add_column("User", style="white", width=6)
    table.add_column("Name", style="green", width=40)
    table.add_column("CPU%", justify="right", width=3)
    table.add_column("Mem%", justify="right", width=3)

    def is_root(username):
        return username == "root" or username == "0"

    for proc in top_processes:
        table.add_row(
            str(proc["pid"]),
            f"[dim]{proc['user']}" if is_root(proc["user"]) else proc["user"],
            proc["name"],
            f"{proc['cpu']:.1f}",
            f"{proc['mem']:.1f}",
        )

    return table


def build_gpu_panel():
    """Build GPU panel for rktop with progress bar."""
    gpu_usage = get_gpu_usage()
    gpu_freq = get_gpu_frequency()
    freq_str = f" {gpu_freq} MHz" if gpu_freq is not None else ""
    progress = Progress(
        TextColumn("Mali0"),
        BarColumn(bar_width=None),
        TextColumn(f"{gpu_usage:.2f}%{freq_str}"),
        expand=True,
    )
    progress.add_task("", total=100, completed=gpu_usage)
    return Panel(
        progress,
        title="GPU",
        padding=(0, 1),
        border_style="green",
        box=box.ROUNDED,
    )


def build_npu_panel():
    loads = get_npu_load()
    if not loads:
        return Panel("NPU not available", title="NPU", box=box.ROUNDED)
    npu_freq = get_npu_frequency()

    progress = Progress(
        TextColumn("{task.description}"),
        BarColumn(bar_width=None),
        TextColumn(f"{{task.percentage:>3.0f}}% {npu_freq:>4d} MHz"),
        expand=True,
    )
    for i, val in enumerate(loads):
        progress.add_task(f"NPU Core {i}", total=100, completed=val)
    return Panel(
        progress,
        title="NPU",
        padding=(0, 1),
        border_style="green",
        box=box.ROUNDED,
    )


def build_rga_panel():
    """Build RGA panel showing graphics accelerator load"""
    sc, rgaload = get_rga_load()
    if not rgaload:
        return Panel("RGA not available", title="RGA", box=box.ROUNDED)
    progress = Progress(
        TextColumn("{task.description}"),
        BarColumn(bar_width=None),
        TextColumn("{task.percentage:>3.0f}%"),
        expand=True,
    )
    sorted_items = sorted(rgaload.items())  # Sort by scheduler name
    for name, val in sorted_items:
        progress.add_task(name, total=100, completed=val)
    return Panel(
        progress,
        title="RGA",
        padding=(0, 1),
        border_style="green",
        box=box.ROUNDED,
    )


def build_sys_panel():
    """Build system information panel with device name and versions"""
    board_name = get_board_name()

    sys_table = Table.grid(expand=True)
    sys_table.add_column()
    sys_table.add_column(justify="right")

    npu_version = get_npu_driver_version().strip()
    rga_version = get_rga_version().strip()
    lib_version = get_librknnrt_version().strip()
    llm_version = get_librkllmrt_version().strip()

    sys_table.add_row(
        "[bold]Board/SoC[/bold]",
        f"[italic]{board_name}[/italic]",
    )
    sys_table.add_row("NPU Driver", npu_version)
    sys_table.add_row("RGA Driver", rga_version)
    sys_table.add_row("RKNN Runtime", lib_version)
    sys_table.add_row("RKLLM Runtime", llm_version)

    return Panel(
        sys_table,
        title="SYS",
        padding=(0, 1),
        border_style="red",
        box=box.ROUNDED,
    )


def build_cpu_panel():
    usage = get_cpu_load()
    freqs = get_cpu_frequencies()

    table = Table.grid(expand=True)
    table.add_column()

    # render each CPU line with usage and frequency
    for cpu_id, u in enumerate(usage):
        freq_mhz = freqs[cpu_id] if cpu_id < len(freqs) else 0
        progress = Progress(
            TextColumn(f"CPU {cpu_id}"),
            BarColumn(bar_width=None),
            TextColumn(f"{u:>3.0f}% {freq_mhz:>4d} MHz"),
            expand=True,
        )
        progress.add_task("", total=100, completed=u)
        table.add_row(progress)

    return Panel(
        table, title="CPU", padding=(1, 2), border_style="cyan", box=box.ROUNDED
    )


def build_mem_panel():
    vm, sm = get_mem_info()
    used_plus_cached = vm.used + vm.cached
    ram_info = f"{human_bytes(used_plus_cached)} / {human_bytes(vm.total)}"
    swap_info = f"{human_bytes(sm.used)} / {human_bytes(sm.total)}"
    cached = human_bytes(getattr(vm, "cached", 0))
    shared = human_bytes(getattr(vm, "shared", 0))
    free = human_bytes(vm.available)
    total = human_bytes(vm.total)
    ram_used = human_bytes(vm.used)
    zused, ztot = 0, 0
    with contextlib.suppress(Exception):
        with open("/sys/block/zram0/mm_stat") as f:
            parts = f.read().split()
            used = int(parts[2])
            limit = int(parts[3])
            zused = used  # RAM used by ZRAM
            ztot = limit  # ZRAM limit

    zram_info = f"{human_bytes(zused)} / {human_bytes(ztot)}"
    zram_pct = (zused / ztot * 100) if ztot > 0 else 0

    details = Table.grid(expand=True)
    details.add_column(justify="left")
    details.add_column(justify="center")
    details.add_column(justify="right")

    details.add_row(
        f"[bold]Total:[/bold] {total}",
        f"[bold]Free:[/bold] {free}",
        f"[bold]Used:[/bold] {ram_used}",
    )
    details.add_row(f"[bold]Cache:[/bold] {cached}", f"[bold]Shared:[/bold] {shared}")

    progress = Progress(
        TextColumn("{task.description}"),
        BarColumn(bar_width=None),
        TextColumn(
            "{task.percentage:>3.0f}% [dim]| {task.fields[info]:>16}", justify="right"
        ),
        expand=True,
    )
    progress.add_task("RAM", total=100, completed=vm.percent, info=ram_info)
    progress.add_task("Swap", total=100, completed=sm.percent, info=swap_info)
    progress.add_task("ZRAM", total=100, completed=zram_pct, info=zram_info)

    return Panel(
        Group(progress, details),
        title="Memory",
        padding=(0, 1),
        border_style="cyan",
        box=box.ROUNDED,
    )


def build_io_table():
    """Panel with disk I/O and network traffic"""
    global PREV_DISK, PREV_TIME, PREV_ADAPTERS
    now = time.time()
    disk = psutil.disk_io_counters()
    adapters = psutil.net_io_counters(pernic=True)

    if PREV_TIME:
        interval = now - PREV_TIME
        if interval > 0:
            read_rate = (disk.read_bytes - PREV_DISK.read_bytes) / interval
            write_rate = (disk.write_bytes - PREV_DISK.write_bytes) / interval
        else:
            read_rate = write_rate = 0
    else:
        interval = 0
        read_rate = write_rate = 0
    PREV_DISK, PREV_TIME = disk, now

    tbl = Table(title="I/O", box=box.ROUNDED, expand=True, padding=(0, 1))
    tbl.add_column("Metric", style="cyan")
    tbl.add_column("Read/RX", justify="right")
    tbl.add_column("Write/TX", justify="right")

    # Disk I/O
    tbl.add_row("Disk", f"{human_bytes(read_rate)}/s", f"{human_bytes(write_rate)}/s")

    # Per-adapter network I/O
    for adapter_name, stats in sorted(adapters.items()):
        if interval > 0 and adapter_name in PREV_ADAPTERS:
            prev_rx, prev_tx = PREV_ADAPTERS[adapter_name]
            adapter_rx_rate = (stats.bytes_recv - prev_rx) / interval
            adapter_tx_rate = (stats.bytes_sent - prev_tx) / interval
            tbl.add_row(
                adapter_name,
                f"{human_bytes(adapter_rx_rate)}/s",
                f"{human_bytes(adapter_tx_rate)}/s",
            )
        PREV_ADAPTERS[adapter_name] = (stats.bytes_recv, stats.bytes_sent)

    return tbl


def build_thermal_table():
    tbl = Table(title="Temperatures", box=box.ROUNDED, expand=True, padding=(0, 1))
    tbl.add_column("Sensor", style="cyan")
    tbl.add_column("Temp", justify="right")
    for name, val in get_thermal():
        tbl.add_row(name, f"{val}°C")
    return tbl


def initialize_cache():
    """OPTIMIZATION: Check hardware availability once at startup"""
    CACHE["has_gpu"] = get_gpu_usage() is not None
    CACHE["has_npu"] = len(get_npu_load()) > 0
    _, rga_loads = get_rga_load()
    CACHE["has_rga"] = bool(rga_loads)
    CACHE["sys_panel"] = build_sys_panel()


def build_layout():
    left_panels = [build_cpu_panel(), build_mem_panel()]
    right_panels = [CACHE["sys_panel"]]
    if CACHE["has_gpu"]:
        right_panels.append(build_gpu_panel())
    if CACHE["has_npu"]:
        right_panels.append(build_npu_panel())
    if CACHE["has_rga"]:
        right_panels.append(build_rga_panel())

    bottom_left_panels = [build_io_table(), build_thermal_table()]

    top_layout = Layout(name="top", size=20, minimum_size=20)
    top_layout.split_row(
        Layout(Group(*left_panels), name="left"),
        Layout(Group(*right_panels), name="right"),
    )
    bottom_layout = Layout(name="bottom")
    bottom_layout.split_row(
        Layout(Group(*bottom_left_panels), name="left", ratio=6),
        Layout(build_process_panel(), name="right", ratio=15),
    )
    root_layout = Layout()
    root_layout.split(
        top_layout,
        bottom_layout,
    )
    return root_layout


def main():
    global SORT_MODE
    initialize_cache()
    signal.signal(signal.SIGINT, signal_handler)  # graceful exit when CTRL+C is pressed

    q = queue.Queue()
    threading.Thread(target=get_key, args=(q,), daemon=True).start()
    old = termios.tcgetattr(sys.stdin)
    try:
        with Live(build_layout(), refresh_per_second=0.75, screen=True) as live:
            while not SHOULD_EXIT:
                time.sleep(1.5)

                # Check for keypresses
                if not q.empty():
                    key = q.get()
                    if key in ["q", "Q", "esc"]:
                        break
                    elif key in ["c", "C"]:
                        if SORT_MODE == "cpu_desc":
                            SORT_MODE = "cpu_asc"
                        else:
                            SORT_MODE = "cpu_desc"
                    elif key in ["m", "M"]:
                        if SORT_MODE == "mem_desc":
                            SORT_MODE = "mem_asc"
                        else:
                            SORT_MODE = "mem_desc"
                    elif key in ["p", "P"]:
                        if SORT_MODE == "pid_desc":
                            SORT_MODE = "pid_asc"
                        else:
                            SORT_MODE = "pid_desc"
                    elif key in ["n", "N"]:
                        if SORT_MODE == "name_desc":
                            SORT_MODE = "name_asc"
                        else:
                            SORT_MODE = "name_desc"

                live.update(build_layout())
    finally:
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old)
        os.system("stty sane")


if __name__ == "__main__":
    if os.geteuid() != 0:
        print("Root permissions required. Use: sudo rktop")
        sys.exit(1)
    main()
